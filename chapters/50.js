export default `
<h3>50. Буфер</h3>

<h5>Что такое буфер?</h5>

<p>Буфер - это место в памяти. JavaScript-разработчики не знакомы с этой концепцией, по крайней мере, они знакомы с ней намного хуже, чем разработчики, пишущие код на C, C++ и Go, которые работают с памятью каждый день. 

<p>Буфер представляет собой фиксированный раздел памяти (размер которого можно изменять), находящийся за пределами движка JavaScript V8. 

<p>Вы можете думать о буфере как о массиве целых чисел, где каждое число - это байт данных. 

<p>В Node.js буфер реализован <a href="https://nodejs.org/api/buffer.html">классом Буфер</a>. 

<h5>Зачем нужен буфер?</h5>

<p>Буферы были представлены для облегчения работы с двоичными данными, в экосистеме, где присутствовали лишь строки. 

<p>Буферы тесно связаны с потоками. Когда процессор потока получает данные быстрее, чем он может их преобразовать, данные помещаются в буфер. 

<p>Простой визуализацией буфера является просмотр видео на YouTube, когда видео загружается быстрее, чем просматривается: в этом случае загруженное видео помещается в буфер. 

<h5>Как создать буфер?</h5>

<p>Буферы создаются с помощью методов <span>Buffer.from()</span>, <span>Buffer.alloc()</span> и <span>Buffer.allocUnsafe()</span>. 

<code>
const buf = Buffer.from('Hey!')
</code>

<ul>
    <li>Buffer.from(array)</li>
    <li>Buffer.from(arrayBuffer[, byteOffset[, length]])</li>
    <li>Buffer.from(buffer)</li>
    <li>Buffer.from(string[, encoding])</li>
</ul>

<p>Вы также можете инициализировать буфер, передав размер в качестве аргумента. Вот как создать буфер размером 1 Кб:

<code>
const buf = Buffer.alloc(1024)
// или 
const buf = Buffer.allocUnsafe(1024)
</code>

<p>Оба метода, <span>alloc</span> и <span>allocUnsafe</span> создают буфер определенного размера в байтах, однако <span>Buffer</span>, созданный с помощью <span>alloc</span> будет инициализирован с нулями, а <span>Buffer</span>, созданный с помощью <span>allocUnsafe</span> не будет инициализирован. Это означает, что <span>allocUnsafe</span> производительнее, чем <span>alloc</span>, но в выделяемой им памяти могут храниться старые данные. 

<p>При чтении буфера может произойти утечка старых (перезаписанных) данных. Вот что делает <span>allocUnsafe</span> небезопасным. Поэтому при его использовании следует быть крайне осторожным. 

<h5>Использование буфера</h5>

<h6>Получение содержимого буфера</h6>

<p>Доступ к буферу, представляющему собой массив байтов, можно получить как к любому массиву:

<code>
const buf = Buffer.from('Hey!')
console.log(buf[0]) // 72
console.log(buf[1]) // 101
console.log(buf[2]) // 121
</code>

<p>Эти числа представляют собой кодовые обозначения символов переданной строки (H => 72, e => 101, y => 121). 

<p>Увидеть содержимое буфера можно с помощью метода <span>toString()</span>: 

<code>
console.log(buf.toString())
</code>

<p>Если вы инициализировали буфер с помощью числа - размера буфера, вы получите доступ к подготовленному разделу памяти, содержащему произвольные данные, т.е. буфер не будет пустым. 

<h6>Получение длины буфера</h6>

<p>Используйте свойство <span>length</span>: 

<code>
const buf = Buffer.from('Hey!')
console.log(buf.length)
</code>

<h6>Перебор содержимого буфера</h6>

<code>
const buf = Buffer.from('Hey!')
for (const i of buf) {
    console.log(i) // 72 101 121 33
}
</code>

<h6>Именение содержимого буфера</h6>

<p>Вы можете записать в буфер строку данных посредством метода <span>write()</span>: 

<code>
const buf = Buffer.alloc(4)
buf.write('Hey!')
</code>

<p>Записывать данные в буфер также можно с помощью скобочной нотации: 

<code>
const buf = Buffer.from('Hey!')
buf[1] = 111 // o 
console.log(buf.toString()) // Hoy!
</code>

<h6>Копирование буфера</h6>

<p>Копировать буфер можно с помощью метода <span>copy()</span>:

<code>
const buf = Buffer.from('Hey!')
let bufcopy = Buffer.alloc(4) // выделяем 4 байта
buf.copy(bufcopy)
</code>

<h6>Получение части буфера</h6>

<p>Если вы хотите получить часть буфера, то можете сделать срез (slice). Срез - это не копия, оригинальный буфер - источник истины для него, поэтому при изменении оригинального буфера изменится и срез. 

<p>Для создания среза используйте метод <span>slice()</span>. Первый параметр - начальная позиция, второй (опциональный) - конечная позиция: 

<code>
const buf = Buffer.from('Hey!')
buf.slice(0).toString() // Hey!
const slice = buf.slice(0, 2)
console.log(slice.toString()) // He
buf[1] = 111 // o
console.log(slice.toString()) // Ho
</code>
`