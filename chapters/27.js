export default `
<h3>27. Цикл событий</h3>

<p>Цикл событий - это важнейшая часть Node.js.</p>

<p>Почему? Потому что это обуславливает асинхронность Node.js, т.е. то, почему он имеет неблокирующий ввод/вывод.</p>

<p>Код в Node.js выполняется в одном потоке. Одновременно выполняется только одна задача.</p>

<p>Это ограничение приносит большую пользу, поскольку вам не приходится заботиться об устранении конкуренции между потоками.</p>

<p>Вам всего лишь следует обращать внимание на то, как написан ваш код и избегать всего, что может заблокировать поток, например, синхронных сетевых соединений или бесконечных циклов.</p> 

<p>Обычно, каждая вкладка браузера имеет собственный цикл событий для изоляции процессов во избежание того, что отдельная страница с бесконечными циклами или сложными вычислениями заблокирует работу всего браузера.</p>

<p>Среда выполнения кода управляет конкуренцией циклов событий, например, с целью обработки обращений к разным прикладным интерфейсам. Веб-воркеры имеют собственный цикл событий.</p>

<p>В Node.js вам следует заботиться о выполнении кода в одном потоке и использовать неблокирующие средства.</p>

<h5>Блокировка цикла событий</h5>

<p>Любой JS-код, выполнение которого занимает много времени, заблокирует выполнение любого другого кода на странице, даже пользовательский интерфейс: пользователь не сможем нажимать на кнопки, переходить по ссылкам, прокручивать страницу и т.д.</p>

<p>Почти все примитивы ввода/вывода в JavaScript являются неблокирующими. Сетевые запросы, работа с файловой системой и т.п. Для решения проблемы блокирующей природы JavaScript применяются функции обратного вызова, промисы и async/await.</p>

<h5>Стек вызовов</h5>

<p>Стек вызовов - это очередь, работающая по принципу LIFO (last in, first out - последним вошел, первым вышел).</p>

<p>Цикл событий периодически проверяет стек вызовов с целью определения наличия в нем функций для выполнения.</p>

<p>При обнаружении такой функции, цикл событий помещает ее в стек вызовов и выполняет.</p>

<p>Вам должен быть хорошо известен стек-трейс (stack trace) ошибок в отладчике или консоли браузера. Браузер определяет название функции по стеку вызовов для предоставления информации о том, какая функция вызвала исключение:</p>

<img src="./img/27-1.png">

<h5>Простое объяснение цикла событий</h5>

<p>Рассмотрим пример:</p>

<code>
    const bar = () => console.log('bar')

    const baz = () => console.log('baz')

    const foo = () => {
        console.log('foo')
        bar()
        baz()
    }
</code>

<p>При запуске кода сначала вызывается <span>foo()</span>. В <span>foo()</span> сначала вызывается <span>bar()</span>, затем <span>baz()</span>.</p>

<p>Cтек вызовов выглядит так:</p>

<img src="./img/27-2.png">

<p>Цикл событий на каждой итерации проверяет, имеются ли в стеке вызовов функции для выполнения:</p>

<img src="./img/27-3.png">

<p>Это происходит до тех пор, пока стек не окажется пустым.</p>

<h5>Выполнение функции, находящейся в очереди</h5>

<p>Приведенный пример не представляет особого интереса: JavaScript определяет наличие функций в стеке вызовов и выполняет их по очереди.</p>

<p>Как отложить выполнение функции до освобождения стека вызовов?</p>

<p>Использование <span>setTimeout(() => {})</span> приводит к тому, что вызванная функция выполняется после других.</p>

<p>Рассмотрим пример:</p>

<code>
    const baz = () => console.log('baz')

    const bar = () => console.log('bar')

    const foo = () => {
        console.log('foo')
        setTimeout(bar, 0)
        baz()
    }

    foo()
</code>

<p>Этот код выводит в консоль следующее:</p>

<code>
    foo 
    baz 
    bar 
</code>

<p>При запуске кода сначала выполняется <span>foo()</span>. В <span>foo()</span> мы сначала вызываем <span>setTimeout()</span>, передавая <span>bar</span> в качестве аргумента и указывая на необходимость немедленного выполнения, устанавливая значение счетчика равным 0. Затем мы вызываем <span>baz()</span>.</p>

<p>Стек вызовов выглядит так:</p>

<img src="./img/27-4.png" alt="">

Вот порядок выполнения функций:

<img src="./img/27-4.png" alt="">

<p>Почему так происходит?</p> 

<h5>Очередь сообщений</h5>

<p>При вызове <span>setTimeout()</span> браузер или Node.js запускают таймер. Поскольку в нашем случае таймер истекает немедленно (мы установили значение счетчика равным 0), функция обратного вызова помещается в очередь сообщений.</p>

<p>В очередь сообщений попадают все пользовательские события, такие как события мыши или клавиатуры, а также ответы на запросы, перед тем, как код получить возможность их обработать. Также сюда попадают события DOM, например, <span>load</span>.</p> 

<p>Цикл событий отдает приоритет стеку вызовов и сперва выполняет находящиеся там функции, и лишь после того, как стек опустеет, цикл обращается к очереди сообщений.</p> 

<p>Мы не ждем выполнения таких функция, как <span>setTimeout()</span> или <span>fetch()</span>, поскольку они предоставляются браузером и имеют собственные потоки для выполнения. Например, если установить значение счетчика равным 2 секундам, нам не придется ждать эти 2 секунды, это произойдет в другом месте.</p> 

<h5>Очередь задач ES6</h5>

<p>ECMAScript 2015 представил концепцию очереди задач, которая используется промисами (также представленными в этом стандарте). Очередь задач представляет собой способ максимально быстрого выполнения результата асинхронной функции без помещения ее в конец стека вызовов.</p> 

<p>Промисы, разрешенные перед завершением выполнения текущей функции, будут выполнены следом за этой функцией.</p>

<p>Можно провести аналогию с американскими горками в парке развлечений: очередь сообщений помещает вас в конец очереди, позади других людей, и вам приходится ждать своей очереди, а очередь задач - это специальный билет, дающий вам право прокатиться на аттракционе сразу после окончания предыдущей поездки.</p>

<p>Пример:</p>

<code>
    const bar = () => console.log('bar')

    const baz = () => console.log('baz')

    const foo = () => {
        console.log('foo')
        setTimeout(bar, 0)
        new Promise((resolve, reject) => 
            resolve('should be right after baz, before bar')
        ).then(resolve => console.log(resolve))
        baz()
    }

    foo()
</code>

<p>Этот код выведет в консоль следующее:</p>

<code>
    foo 
    baz 
    should be right after baz, before bar
    baz
</code>

<p>Существует большая разница между промисами (и async/await, основанном на промисах) и старыми-добрыми асинхронными функциями типа <span>setTimeout()</span> и другими прикладными интерфейсами среды выполнения кода.</p>
`